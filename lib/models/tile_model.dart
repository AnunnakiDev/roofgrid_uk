import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:hive/hive.dart';

part 'tile_model.g.dart'; // This will be generated by build_runner

@HiveType(typeId: 0)
enum TileSlateType {
  @HiveField(0)
  slate,
  @HiveField(1)
  fibreCementSlate,
  @HiveField(2)
  interlockingTile,
  @HiveField(3)
  plainTile,
  @HiveField(4)
  concreteTile,
  @HiveField(5)
  pantile,
  @HiveField(6)
  unknown,
}

@HiveType(typeId: 1)
class TileModel {
  @HiveField(0)
  final String id;
  @HiveField(1)
  final String name;
  @HiveField(2)
  final String manufacturer;
  @HiveField(3)
  final TileSlateType materialType;
  @HiveField(4)
  final String description;
  @HiveField(5)
  final bool isPublic;
  @HiveField(6)
  final bool isApproved;
  @HiveField(7)
  final String createdById;
  @HiveField(8)
  final DateTime createdAt;
  @HiveField(9)
  final DateTime updatedAt;
  @HiveField(10)
  final double slateTileHeight;
  @HiveField(11)
  final double tileCoverWidth;
  @HiveField(12)
  final double minGauge;
  @HiveField(13)
  final double maxGauge;
  @HiveField(14)
  final double minSpacing;
  @HiveField(15)
  final double maxSpacing;
  @HiveField(16)
  final double? leftHandTileWidth;
  @HiveField(17)
  final bool defaultCrossBonded;
  @HiveField(18)
  final String? dataSheet; // Added field for datasheet URL
  @HiveField(19)
  final String? image; // Added field for image URL

  TileModel({
    required this.id,
    required this.name,
    required this.manufacturer,
    required this.materialType,
    required this.description,
    required this.isPublic,
    required this.isApproved,
    required this.createdById,
    required this.createdAt,
    DateTime? updatedAt,
    required this.slateTileHeight,
    required this.tileCoverWidth,
    required this.minGauge,
    required this.maxGauge,
    required this.minSpacing,
    required this.maxSpacing,
    this.leftHandTileWidth,
    required this.defaultCrossBonded,
    this.dataSheet,
    this.image,
  }) : updatedAt = updatedAt ?? DateTime.now();

  String get materialTypeString {
    switch (materialType) {
      case TileSlateType.slate:
        return 'Slate';
      case TileSlateType.fibreCementSlate:
        return 'Fibre Cement Slate';
      case TileSlateType.interlockingTile:
        return 'Interlocking Tile';
      case TileSlateType.plainTile:
        return 'Plain Tile';
      case TileSlateType.concreteTile:
        return 'Concrete Tile';
      case TileSlateType.pantile:
        return 'Pantile';
      case TileSlateType.unknown:
        return 'Unknown';
    }
  }

  factory TileModel.fromJson(Map<String, dynamic> json) {
    // Map Firestore TileSlateType string to TileSlateType enum
    TileSlateType parseTileSlateType(String? type) {
      switch (type?.trim()) {
        case 'Slate':
          return TileSlateType.slate;
        case 'Fibre Cement Slate':
          return TileSlateType.fibreCementSlate;
        case 'Interlocking Tile':
          return TileSlateType.interlockingTile;
        case 'Plain Tile':
          return TileSlateType.plainTile;
        case 'Concrete Tile':
          return TileSlateType.concreteTile;
        case 'Pantile':
          return TileSlateType.pantile;
        case 'Unknown':
        default:
          return TileSlateType.unknown;
      }
    }

    // Helper to parse a value that might be a string or number into a double
    double parseNumber(dynamic value) {
      if (value is num) {
        return value.toDouble();
      } else if (value is String) {
        return double.tryParse(value) ?? 0.0;
      }
      return 0.0;
    }

    return TileModel(
      id: json['id'].toString(), // Handles int or String
      name: json['name'] as String? ?? '',
      manufacturer: json['manufacturer'] as String? ?? '',
      materialType: parseTileSlateType(json['TileSlateType'] as String?),
      description: json['description'] as String? ?? '',
      isPublic: json['isPublic'] as bool? ?? false,
      isApproved: json['isApproved'] as bool? ?? false,
      createdById: json['createdById'].toString(), // Handles int or String
      createdAt: (json['createdAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      updatedAt: (json['updatedAt'] as Timestamp?)?.toDate() ?? DateTime.now(),
      slateTileHeight: parseNumber(json['slateTileHeight']),
      tileCoverWidth: parseNumber(json['tileCoverWidth']),
      minGauge: parseNumber(json['minGauge']),
      maxGauge: parseNumber(json['maxGauge']),
      minSpacing: parseNumber(json['minSpacing']),
      maxSpacing: parseNumber(json['maxSpacing']),
      leftHandTileWidth: json['leftHandTileWidth'] != null
          ? parseNumber(json['leftHandTileWidth'])
          : null,
      defaultCrossBonded: json['defaultCrossBonded'] as bool? ?? false,
      dataSheet: json['dataSheet'] as String?,
      image: json['image'] as String?,
    );
  }

  factory TileModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>?;
    if (data == null) {
      throw Exception('Tile data not found for ID: ${doc.id}');
    }
    return TileModel.fromJson(data);
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'name': name,
      'manufacturer': manufacturer,
      'TileSlateType': materialTypeString, // Store as human-readable string
      'description': description,
      'isPublic': isPublic,
      'isApproved': isApproved,
      'createdById': createdById,
      'createdAt': createdAt,
      'updatedAt': updatedAt,
      'slateTileHeight': slateTileHeight,
      'tileCoverWidth': tileCoverWidth,
      'minGauge': minGauge,
      'maxGauge': maxGauge,
      'minSpacing': minSpacing,
      'maxSpacing': maxSpacing,
      if (leftHandTileWidth != null) 'leftHandTileWidth': leftHandTileWidth,
      'defaultCrossBonded': defaultCrossBonded,
      if (dataSheet != null) 'dataSheet': dataSheet,
      if (image != null) 'image': image,
    };
  }

  TileModel copyWith({
    String? id,
    String? name,
    String? manufacturer,
    TileSlateType? materialType,
    String? description,
    bool? isPublic,
    bool? isApproved,
    String? createdById,
    DateTime? createdAt,
    DateTime? updatedAt,
    double? slateTileHeight,
    double? tileCoverWidth,
    double? minGauge,
    double? maxGauge,
    double? minSpacing,
    double? maxSpacing,
    double? leftHandTileWidth,
    bool? defaultCrossBonded,
    String? dataSheet,
    String? image,
  }) {
    return TileModel(
      id: id ?? this.id,
      name: name ?? this.name,
      manufacturer: manufacturer ?? this.manufacturer,
      materialType: materialType ?? this.materialType,
      description: description ?? this.description,
      isPublic: isPublic ?? this.isPublic,
      isApproved: isApproved ?? this.isApproved,
      createdById: createdById ?? this.createdById,
      createdAt: createdAt ?? this.createdAt,
      updatedAt: updatedAt ?? this.updatedAt,
      slateTileHeight: slateTileHeight ?? this.slateTileHeight,
      tileCoverWidth: tileCoverWidth ?? this.tileCoverWidth,
      minGauge: minGauge ?? this.minGauge,
      maxGauge: maxGauge ?? this.maxGauge,
      minSpacing: minSpacing ?? this.minSpacing,
      maxSpacing: maxSpacing ?? this.maxSpacing,
      leftHandTileWidth: leftHandTileWidth ?? this.leftHandTileWidth,
      defaultCrossBonded: defaultCrossBonded ?? this.defaultCrossBonded,
      dataSheet: dataSheet ?? this.dataSheet,
      image: image ?? this.image,
    );
  }
}

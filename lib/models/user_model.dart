import 'package:cloud_firestore/cloud_firestore.dart';
import 'package:firebase_auth/firebase_auth.dart';
import 'package:hive/hive.dart';

part 'user_model.g.dart'; // This will be generated by build_runner

@HiveType(typeId: 2)
enum UserRole {
  @HiveField(0)
  free,
  @HiveField(1)
  pro,
  @HiveField(2)
  admin,
}

@HiveType(typeId: 3)
class UserModel {
  @HiveField(0)
  final String id;
  @HiveField(1)
  final String? email;
  @HiveField(2)
  final String? displayName;
  @HiveField(3)
  final String? photoURL;
  @HiveField(4)
  final String? phone; // Added field for phone number
  @HiveField(5)
  final String? subscription; // Added field for subscription status
  @HiveField(6)
  final String? profileImage; // Added field for profile image URL
  @HiveField(7)
  final UserRole role;
  @HiveField(8)
  final DateTime? proTrialStartDate;
  @HiveField(9)
  final DateTime? proTrialEndDate;
  @HiveField(10)
  final DateTime? subscriptionEndDate;
  @HiveField(11)
  final DateTime createdAt;
  @HiveField(12)
  final DateTime? lastLoginAt;

  const UserModel({
    required this.id,
    this.email,
    this.displayName,
    this.photoURL,
    this.phone,
    this.subscription,
    this.profileImage,
    this.role = UserRole.free,
    this.proTrialStartDate,
    this.proTrialEndDate,
    this.subscriptionEndDate,
    required this.createdAt,
    this.lastLoginAt,
  });

  UserModel.fromFirebaseUser(
    User user, {
    UserRole role = UserRole.free,
    DateTime? proTrialStartDate,
    DateTime? proTrialEndDate,
    DateTime? subscriptionEndDate,
    DateTime? createdAt,
    DateTime? lastLoginAt,
    String? phone,
    String? subscription,
    String? profileImage,
  }) : this(
          id: user.uid,
          email: user.email,
          displayName: user.displayName,
          photoURL: user.photoURL,
          phone: phone,
          subscription: subscription,
          profileImage: profileImage,
          role: role,
          proTrialStartDate: proTrialStartDate,
          proTrialEndDate: proTrialEndDate,
          subscriptionEndDate: subscriptionEndDate,
          createdAt: createdAt ?? DateTime.now(),
          lastLoginAt: lastLoginAt ?? DateTime.now(),
        );

  factory UserModel.fromFirestore(DocumentSnapshot doc) {
    final data = doc.data() as Map<String, dynamic>?;
    if (data == null) {
      throw Exception('User data not found for ID: ${doc.id}');
    }

    final userRole = UserRole.values.firstWhere(
      (r) =>
          r.toString().split('.').last == (data['role'] as String? ?? 'free'),
      orElse: () => UserRole.free,
    );
    print('Parsed role for user ${doc.id}: $userRole'); // Debug log

    return UserModel(
      id: doc.id,
      email: data['email'] as String?,
      displayName: data['displayName'] as String?,
      photoURL: data['photoURL'] as String?,
      phone: data['phone'] as String?,
      subscription: data['subscription'] as String?,
      profileImage: data['profileImage'] as String?,
      role: userRole,
      proTrialStartDate: data['proTrialStartDate'] != null
          ? (data['proTrialStartDate'] as Timestamp).toDate()
          : null,
      proTrialEndDate: data['proTrialEndDate'] != null
          ? (data['proTrialEndDate'] as Timestamp).toDate()
          : null,
      subscriptionEndDate: data['subscriptionEndDate'] != null
          ? (data['subscriptionEndDate'] as Timestamp).toDate()
          : null,
      createdAt: data['createdAt'] != null
          ? (data['createdAt'] as Timestamp).toDate()
          : DateTime.now(),
      lastLoginAt: data['lastLoginAt'] != null
          ? (data['lastLoginAt'] as Timestamp).toDate()
          : DateTime.now(),
    );
  }

  UserModel copyWith({
    String? id,
    String? email,
    String? displayName,
    String? photoURL,
    String? phone,
    String? subscription,
    String? profileImage,
    UserRole? role,
    DateTime? proTrialStartDate,
    DateTime? proTrialEndDate,
    DateTime? subscriptionEndDate,
    DateTime? createdAt,
    DateTime? lastLoginAt,
  }) {
    return UserModel(
      id: id ?? this.id,
      email: email ?? this.email,
      displayName: displayName ?? this.displayName,
      photoURL: photoURL ?? this.photoURL,
      phone: phone ?? this.phone,
      subscription: subscription ?? this.subscription,
      profileImage: profileImage ?? this.profileImage,
      role: role ?? this.role,
      proTrialStartDate: proTrialStartDate ?? this.proTrialStartDate,
      proTrialEndDate: proTrialEndDate ?? this.proTrialEndDate,
      subscriptionEndDate: subscriptionEndDate ?? this.subscriptionEndDate,
      createdAt: createdAt ?? this.createdAt,
      lastLoginAt: lastLoginAt ?? this.lastLoginAt,
    );
  }

  Map<String, dynamic> toJson() {
    return {
      'id': id,
      'email': email,
      'displayName': displayName,
      'photoURL': photoURL,
      'phone': phone,
      'subscription': subscription,
      'profileImage': profileImage,
      'role': role.toString().split('.').last,
      'proTrialStartDate': proTrialStartDate != null
          ? Timestamp.fromDate(proTrialStartDate!)
          : null,
      'proTrialEndDate':
          proTrialEndDate != null ? Timestamp.fromDate(proTrialEndDate!) : null,
      'subscriptionEndDate': subscriptionEndDate != null
          ? Timestamp.fromDate(subscriptionEndDate!)
          : null,
      'createdAt': Timestamp.fromDate(createdAt),
      'lastLoginAt':
          lastLoginAt != null ? Timestamp.fromDate(lastLoginAt!) : null,
    };
  }

  factory UserModel.fromJson(Map<String, dynamic> json) {
    return UserModel(
      id: json['id'] as String,
      email: json['email'] as String?,
      displayName: json['displayName'] as String?,
      photoURL: json['photoURL'] as String?,
      phone: json['phone'] as String?,
      subscription: json['subscription'] as String?,
      profileImage: json['profileImage'] as String?,
      role: UserRole.values.firstWhere(
        (r) =>
            r.toString().split('.').last == (json['role'] as String? ?? 'free'),
        orElse: () => UserRole.free,
      ),
      proTrialStartDate: json['proTrialStartDate'] != null
          ? DateTime.parse(json['proTrialStartDate'] as String)
          : null,
      proTrialEndDate: json['proTrialEndDate'] != null
          ? DateTime.parse(json['proTrialEndDate'] as String)
          : null,
      subscriptionEndDate: json['subscriptionEndDate'] != null
          ? DateTime.parse(json['subscriptionEndDate'] as String)
          : null,
      createdAt: json['createdAt'] != null
          ? DateTime.parse(json['createdAt'] as String)
          : DateTime.now(),
      lastLoginAt: json['lastLoginAt'] != null
          ? DateTime.parse(json['lastLoginAt'] as String)
          : null,
    );
  }

  bool get isTrialActive =>
      (role == UserRole.pro || role == UserRole.admin) &&
      proTrialEndDate != null &&
      proTrialEndDate!.isAfter(DateTime.now());

  bool get isTrialExpired =>
      (role == UserRole.pro || role == UserRole.admin) &&
      proTrialEndDate != null &&
      proTrialEndDate!.isBefore(DateTime.now());

  bool get isTrialAboutToExpire => isTrialActive && remainingTrialDays <= 7;

  bool get isSubscribed =>
      (role == UserRole.pro || role == UserRole.admin) &&
      subscriptionEndDate != null &&
      subscriptionEndDate!.isAfter(DateTime.now());

  bool get isPro =>
      (role == UserRole.pro || role == UserRole.admin) &&
      (isTrialActive || isSubscribed);

  bool get isAdmin =>
      role == UserRole.admin; // Ensures isAdmin is true for admin role

  int get remainingTrialDays {
    if (isTrialActive && proTrialEndDate != null) {
      return proTrialEndDate!.difference(DateTime.now()).inDays;
    }
    return 0;
  }
}
